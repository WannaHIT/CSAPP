## 实验设定

函数栈里面的指令可执行，因为并没有限制可执行区域。

## 预备知识

**函数劫持**或**栈帧劫持**的问题，涉及到修改函数的返回地址，从而在执行过程中跳转到另一个函数的首地址。根据你的描述，涉及修改了函数 `a` 的栈帧中的指令（或者说返回地址）为另一个函数 `b` 的首地址。接下来我们分析修改后的行为：

------

### 1. **跳转行为**

当函数 `a` 的栈帧中被劫持的返回地址指向 `b`，程序执行完 `a` 后，它不会返回到 `a` 的正常返回位置，而是跳转到 `b` 的起始地址执行。

示例：

```c
void a() {
    int x = 10;
    // 正常流程应该返回到调用者
}

void b() {
    int y = 20;
    // b 的代码
}
```

如果 `a` 的栈帧返回地址被修改为 `b` 的首地址，那么 `a` 执行结束后会直接跳转到 `b`，而不是返回到调用 `a` 的位置。

------

### 2. **栈帧归属**

执行 `b` 的代码时，仍然使用的是 `a` 的栈帧，**栈帧不会自动切换到 `b` 的栈帧**，因为：

- 栈帧是在函数调用时创建的，`b` 这里并没有被正常调用，因此没有自己的栈帧。
- 由于是 `a` 的栈帧在控制执行，所有的局部变量、参数等都还是 `a` 的内容。

换句话说，**执行 `b` 的代码时，当前的栈帧实际上仍然是 `a` 的栈帧**。此时 `b` 中的局部变量、参数等都没有正常的内存布局，可能会出现未定义的行为。

------

### 3. **实际效果**

劫持返回地址会导致以下几种后果：

- **异常行为**：由于 `b` 依赖 `b` 自己的栈帧，执行 `b` 的局部变量操作、函数参数访问等操作时，可能会访问到错误或未初始化的内存。
- **潜在崩溃**：如果 `b` 执行完后尝试返回，它会使用 `a` 的栈帧的返回地址，可能导致程序崩溃。

------

### 4. **劫持返回地址的实际应用**

在一些攻击技术（如**缓冲区溢出攻击**）中，常常会利用这种方式来跳转到恶意代码。通过覆盖函数返回地址，攻击者可以劫持程序的控制流，执行他们希望的代码。

------

### 总结

- **执行过程中**，修改后的代码会在 `a` 的栈帧中执行 `b` 的指令。
- **栈帧归属仍然是 `a`**，而不是 `b`。
- 这种操作通常会引发未定义行为或程序崩溃，尤其是当 `b` 尝试访问局部变量或返回时。