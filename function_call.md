好的，这是一个非常核心且重要的概念，理解它能让你对程序是如何在底层运行的有非常深刻的认识。我们会用一个简单的C语言例子，一步步、非常详细地追踪 `main` 函数调用 `add` 函数再返回的全过程中，`rip`、`rsp` 和 `rbp` 这三个关键寄存器的变化。

---

#### 栈是一个连续的内存空间，函数调用时，新的栈帧会紧挨着旧的栈帧（和返回地址）向上（低地址方向）搭建起来

------



### 预备知识：三个主角寄存器



首先，我们来明确这三个寄存器的角色（在x86-64架构下）：

1. **`rip` (Instruction Pointer - 指令指针寄存器)**
   - **角色**：CPU的“眼睛”或“程序计数器”。
   - **作用**：它永远指向内存中**下一条**将要被执行的指令的地址。CPU就是根据 `rip` 的值去取指令并执行的。`rip` 的值不能被程序员直接修改，它由 `call`、`ret`、`jmp` 等跳转指令来隐式地改变。
2. **`rsp` (Stack Pointer - 栈顶指针寄存器)**
   - **角色**：栈的“导航员”。
   - **作用**：它永远指向**栈的顶部**。在x86-64中，栈是向下增长的，所以每当有数据入栈（`push`），`rsp` 的值会**减小**；当有数据出栈（`pop`），`rsp` 的值会**增大**。`rsp` 是一个时刻在动态变化的指针。
3. **`rbp` (Base Pointer - 基址指针寄存器)**
   - **角色**：当前函数栈帧的“定海神针”。
   - **作用**：它指向当前函数**栈帧 (Stack Frame) 的底部**。在一个函数执行期间，`rbp` 的值通常是**固定不变的**，这使得编译器能以 `rbp` 为基准，用固定的偏移量（如 `[rbp-8]`、`[rbp-16]`）来方便地访问函数的局部变量和参数，而不用担心 `rsp` 的动态变化。



### 示例代码



我们将用下面这段简单的C代码作为分析蓝本：

C

```
int add(int a, int b) {
    int result = a + b;
    return result;
}

int main() {
    int x = 10;
    int y = 20;
    int z = add(x, y); // 我们将聚焦于这一行
    return 0;
}
```

*我们假设编译器（如GCC）在没有开启极致优化的情况下（比如 `-O0`），会完整地生成函数栈帧。*

------



### 详细步骤分解





#### 阶段一：在 `main` 函数中，准备调用 `add`



此时，程序正在 `main` 函数中执行。

- **`rip`**: 指向 `main` 函数内部、`call add` 指令之前的某条指令。
- **`rsp` & `rbp`**: 指向 `main` 函数自己的栈帧。`rbp` 固定在 `main` 栈帧的底部，`rsp` 在顶部。局部变量 `x`, `y`, `z` 就存放在 `rbp` 和 `rsp` 之间的栈空间里。

调用前的准备动作：

根据x86-64调用约定（System V ABI），前几个简单的参数是通过寄存器传递的。

1. `mov edi, [rbp - 4]`  ; 将 `main` 的局部变量 `x` 的值放入 `edi` 寄存器（作为`add`的第一个参数`a`）。
2. `mov esi, [rbp - 8]`  ; 将 `main` 的局部变量 `y` 的值放入 `esi` 寄存器（作为`add`的第二个参数`b`）。

此时 `rip` 即将指向 `call add` 指令。`rsp` 和 `rbp` 保持不变。



#### 阶段二：执行 `call add` 指令（关键跳转）



这是整个过程最关键的一步，`call` 指令会执行**两个原子操作**：

1. **保存返回地址**：CPU会将 `call` 指令**下一条**指令的地址（也就是 `add` 函数返回后应该继续执行的地方）压入栈中。
   - **`rsp` 的变化**：`rsp` 的值**减 8**（因为地址是64位的，占8个字节），指向这个刚刚入栈的返回地址。
2. **跳转到目标函数**：CPU会无条件地将 `add` 函数的起始地址加载到 `rip` 寄存器中。
   - **`rip` 的变化**：`rip` 的值**变为 `add` 函数第一条指令的地址**。

现在，CPU的控制权已经从 `main` 转移到了 `add`。



#### 阶段三：`add` 函数的“函数序言 (Function Prologue)”



`add` 函数被调用后，第一件事是建立自己的栈帧，这是一个非常标准的流程，被称为“函数序言”。

- **`rip`**: 正在执行 `add` 函数开头的几条指令。

1. **`push rbp`**: 保存调用者（`main` 函数）的 `rbp` 值。因为 `add` 函数要用 `rbp` 寄存器，所以必须先把 `main` 的 `rbp` 存起来，等返回时再恢复。
   - **`rsp` 的变化**：`rsp` **再减 8**。现在栈顶存放的是 `main` 函数的 `rbp` 值。
2. **`mov rbp, rsp`**: 设置 `add` 函数自己的新栈帧基址。让 `rbp` 指向当前的栈顶 `rsp`。
   - **`rbp` 的变化**：`rbp` 的值**更新为当前 `rsp` 的值**。从此，`rbp` 在 `add` 函数内部就固定了，作为访问局部变量的基准。
3. **`sub rsp, 16`** (或其他大小): 为 `add` 函数的局部变量（比如 `result`）在栈上分配空间。
   - **`rsp` 的变化**：`rsp` **再减 16**。栈顶指针下移，留出空间。

至此，`add` 函数的栈帧建立完毕。形成了一个“栈帧链”：新的 `rbp` 指向的内存地址里，存放着旧的 `rbp` 的值。



#### 阶段四：执行 `add` 函数体



- **`rip`**: 依次执行 `add` 函数的指令，比如 `add edi, esi` 和 `mov [rbp-4], eax` 等。
- **`rsp`, `rbp`**: 在函数体执行期间保持不变。
- 返回值 `result` 最终会被放入 `eax` 寄存器，这也是调用约定规定的。



#### 阶段五：`add` 函数的“函数尾声 (Function Epilogue)”



函数执行完毕，需要拆除自己的栈帧并返回。这个过程和“序言”正好相反。

1. **`leave`**: 这条指令等价于下面两条指令，用于恢复调用者的栈帧。
   - `mov rsp, rbp`：释放局部变量空间，直接将 `rsp` 指向 `rbp`。
   - `pop rbp`：将栈顶的值（也就是之前存的`main`的`rbp`）弹出到 `rbp` 寄存器。
   - **`rsp` 的变化**：因为 `pop` 操作，`rsp` **加 8**。
   - **`rbp` 的变化**：`rbp` 被**恢复成 `main` 函数的 `rbp` 值**。
2. **`ret`**: 这是返回指令，它只做一件事。
   - 将当前栈顶的值（也就是阶段二中存的**返回地址**）弹出到 `rip` 寄存器。
   - **`rsp` 的变化**：因为 `pop` 操作，`rsp` **再加 8**。
   - **`rip` 的变化**：`rip` 被**恢复成 `main` 函数中 `call` 指令的下一条指令的地址**。



#### 阶段六：返回 `main` 函数



- **`rip`**: 已经回到了 `main` 函数，准备执行 `call` 之后的代码（比如把 `eax` 中的返回值存到 `z` 的内存空间）。
- **`rsp` 和 `rbp`**: 已经**完美地恢复**到了调用 `add` 函数之前的状态。对于 `main` 函数来说，栈是平衡的，一切就像没发生过一样。



### 总结



| 阶段          | `rip` (指令指针) | `rsp` (栈顶指针)                                       | `rbp` (基址指针)                 |
| ------------- | ---------------- | ------------------------------------------------------ | -------------------------------- |
| **调用前**    | 在`main`中移动   | 指向`main`栈顶                                         | 指向`main`栈底（固定）           |
| **`call`**    | **跳转到`add`**  | **-8** (压入返回地址)                                  | 不变                             |
| **`add`序言** | 在`add`中移动    | **-8** (压入旧`rbp`)，再**减去N** (为局部变量分配空间) | **更新为`add`的新基址**          |
| **`add`执行** | 在`add`中移动    | 固定                                                   | 固定                             |
| **`add`尾声** | 在`add`中移动    | **恢复**到调用者（`main`）的栈顶                       | **恢复**成调用者（`main`）的基址 |
| **`ret`**     | **跳转回`main`** | **+8** (弹出返回地址)                                  | 已恢复                           |
| **返回后**    | 在`main`中移动   | 已恢复                                                 | 已恢复                           |

这个“建立栈帧 -> 拆除栈帧”的舞蹈，是所有现代编程语言函数调用的基础，理解它对调试、性能分析和理解底层都至关重要。